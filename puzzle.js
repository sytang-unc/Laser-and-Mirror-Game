/*********************************ENUMS************************************/

/*
 * Remove's ambiguity when using a number to refer
 * to a side of grid
 */

var sideEnum = {
	TOP: 0,
	RIGHT: 1,
	BOTTOM: 2,
	LEFT: 3
};

/*
 * A bumper with consistent orientation keeps the same sign after reflection.
 * For example, something moving positively in X direction moves positively
 * 	in Y direction after meeting a consistent bumper.
 * Likewise, something moving positively in X direction moves negatively
 *	in Y direction after meeting a reversed bumper.
 * Using this representation of bumpers because how a bumper that looks like
 *	"/" behaves depends on what directions are positive.
 */

var orientEnum = {
	CONS: 0,
	REV: 1
};

/*
 * for representing directions
 */

var dirEnum = {
	UP: new Coord(0, 1),
	RIGHT: new Coord(1, 0),
	DOWN: new Coord(0, -1),
	LEFT: new Coord(-1, 0)
};

/***********************************GENERATION****************************************/

/*
 * the puzzle object is assumed to have properties
 *	-gridSize, dimensions of grid are (gridSize x gridSize)
 *		not counting entry/exit squares
 *	-grid, representation of the puzzle grid, contains info on which squares have bumpers
 *	-level, maps to number of hidden mirrors, cannot be larger than 4
 *	-decNum, number of decoy mirrors
 *	-pathNum, number of init path mirrors
 *	-side, defines side of exit
 *	-index, defines index of side of exit
 *	-clues, the clues for the puzzle (not generated by constructor)
 *	-clueGrid, grid that has which square has what variable (X, Y, Z, etc)
 */

var puzzle = function (gridSize_init, level_init, dec_init = -1, path_init = -1){
	if (level_init < 0 || level_init > 4){
		//console.log("Invalid level value");
		return;
	}
	this.gridSize = gridSize_init;
	this.grid = new Array(gridSize_init);
	this.clueGrid = new Array(gridSize_init);
	var i;
	for(i = 0; i < gridSize_init; i++){
		this.grid[i] = new Array(gridSize_init);
		this.clueGrid[i] = new Array(gridSize_init);
		var j;
		for(j = 0; j < gridSize_init; j++){
			this.grid[i][j] = 0;
			this.clueGrid[i][j] = 0;
		}
	}
	this.level = level_init;
	this.decNum = (dec_init == -1)? level_init + 2: dec_init;
	this.pathNum = (path_init == -1)? level_init: path_init;
	this.side = rand(0,3);
	this.index = rand(0, gridSize_init - 1);
	this.clues = new Array(2*level_init + 1);
	this.shot = 0;

	this.sol = [orientEnum.CONS, orientEnum.REV, orientEnum.CONS, orientEnum.REV];
	this.cluePool = [
		"If REV is in A1, then CONS is in A2",
		"If REV is not in A1, then CONS is in A3",
		"If CONS is in A2, then CONS is in A3 and REV is in A4",
		"If CONS is not in A2, then REV is in A4",
		"If CONS is in A3, then REV is in A4 and CONS is in A5",
		"If CONS is not in A3, then CONS is in A5",
		"If REV is in A4, then CONS is in A5 and REV is in A6",
		"If REV is not in A4, then CONS is in A5"
	];
	this.variablePool = ["Z", "Y", "X", "W", "V", "U"];

	/*
	 * Creates bumpers along the initial path
	 * See Andy Green's commentary
	 */
	this.createPathBumpers = function() {
		var bumpCount = this.pathNum;
		var i, j;
		var dir;
		var initSqrArray = this.getInitDirAndSquare();
		var initPos = new Coord(initSqrArray[0], initSqrArray[1]);
		//console.log("init position is: " + initPos.x + ", " + initPos.y);
		var pos;
		var bump;
		var initDir = initSqrArray[2];
		//console.log("init dir is : " + initDir.x + ", " + initDir.y);
		var pathGrid;
		var bumpGrid;
		var bumperList = new Array(bumpCount);
		var posList = new Array(bumpCount);
		var madePath = 0;
		pathGrid = new Array(this.gridSize);
		bumpGrid = new Array(this.gridSize);
		for(i = 0; i < this.gridSize; i++){
			pathGrid[i] = new Array(this.gridSize);
			bumpGrid[i] = new Array(this.gridSize);
		}
		do{
			for(i = 0; i < this.gridSize; i++){
				for(j = 0; j < this.gridSize; j++){
					pathGrid[i][j] = 0;
					bumpGrid[i][j] = 0;
				}
			}
			pos = initPos.copyCoord();
			dir = initDir.copyCoord();
			pathGrid[pos.x][pos.y] = 1;
			for(i = 0; i < bumpCount; i++){
				//console.log("Traveling " + dir.x + ", " + dir.y);
				var dist = this.borderDistance(dir, pos);
				var steps = rand(1,dist);
				//console.log("Steps " + steps);
				//if (dist < 1) console.log("dist bad: " +
				//	dist + ", " + dir.x + "," + dir.y + "\n");
				if (pathGrid[pos.x + steps*dir.x][pos.y + steps*dir.y]){
					//console.log("broke1\n");
					break;
				}
				var breakCond = 0;
				for(j = 0; j < steps; j++){
					pos = new Coord(pos.x + dir.x, pos.y + dir.y);
					pathGrid[pos.x][pos.y] = 1;
					if (bumpGrid[pos.x][pos.y]) breakCond = 1;
				}
				//console.log("pos is " + pos.x + ", " + pos.y);
				if (breakCond) {
					//console.log("broke2\n");
					break;
				}
				posList[i] = pos.copyCoord();
				bump = this.newBumper(pos.copyCoord(), dir.copyCoord(), i == bumpCount - 1);
				bumpGrid[pos.x][pos.y] = 1;
				bumperList[i] = bump;
				dir = bump.reflect(dir);
				if (i == bumpCount - 1){
					madePath = 1;
				}
			}
			dist = this.borderDistance(dir, pos);
			for(j = 0; j < dist; j++){
				pos = new Coord(pos.x + dir.x, pos.y + dir.y);
				pathGrid[pos.x][pos.y] = 1;
				if (bumpGrid[pos.x][pos.y]){
					madePath = 0;
				}
			}
		}
		while(!madePath);
		for(i = 0; i < bumpCount; i++){
			this.grid[posList[i].x][posList[i].y] = bumperList[i];
		}
		this.pathGrid = pathGrid;
	}

	/* Add decoy bumpers to puzzle */
	this.decoyBumpers = function(){
		var bumpCount = this.decNum;
		do{
			var i,j;
			i = rand(0,this.gridSize-1);
			j = rand(0, this.gridSize-1);
			if (!this.pathGrid[i][j]){
				bumpCount--;
				this.grid[i][j] = new Bumper(rand(0,1), 1);
			}
		}
		while(bumpCount > 0);
	}

	/*
	 * Pretty much lifted exactly as is from Andy Green's code
	 * Calculates the number of cell steps from position "pos"
	 * to the last cell in the grid traveling in direction "dir"
	 */

	this.borderDistance = function(dir, pos){
		if (dir.x == -1){
			return pos.x;
		}
		if (dir.x == 1){
			return this.gridSize-1-pos.x;
		}
		if (dir.y == -1){
			return pos.y;
		}
		if (dir.y == 1){
			return this.gridSize-1-pos.y;
		}
		//console.log("Unexpected direction\n");
		return -1;
	}

	/*
	 * Helper function for generating paths. Important to
	 * make sure new bumpers reflect back into grid when creating
	 * path bumpers
	 */
	this.newBumper = function(posit, direc, isLast){
		var i,j;
		var bumperOut = new Bumper(rand(0,1), 0);
		if (!isLast){
			var testDir = bumperOut.reflect(direc);
			i = posit.x + testDir.x;
			j = posit.y + testDir.y;
			if (i < 0 || i >= this.gridSize || j < 0 || j >= this.gridSize){
				bumperOut = new Bumper(bumperOut.orient == orientEnum.CONS? orientEnum.REV: orientEnum.CONS, 0);
			}
		}
		return bumperOut;
	}

	/*
	 * Choose an entry (or exit) position and direction
	 */
	this.getInitDirAndSquare = function(){
		var i,j;
		var dir;
		switch(this.side){
			case sideEnum.TOP:
				dir = dirEnum.DOWN.copyCoord();
				i = this.index;
				j = this.gridSize - 1;
				break;
			case sideEnum.BOTTOM:
				dir = dirEnum.UP.copyCoord();
				i = this.index;
				j = 0;
				break;
			case sideEnum.LEFT:
				dir = dirEnum.RIGHT.copyCoord();
				i = 0;
				j = this.index;
				break;
			case sideEnum.RIGHT:
				dir = dirEnum.LEFT.copyCoord();
				i = this.gridSize - 1;
				j = this.index;
				break;
		}
		out = [i, j, dir];
		return out;
	}

	this.createHiddenAndClues = function(){
		if (this.level == 0){
			this.clues[0] = "There are 0 hidden mirrors";
			return;
		}
		var usedGrid = new Array(this.gridSize);
		var i,j,k;
		for (i = 0; i < this.gridSize; i++){
			usedGrid[i] = new Array(this.gridSize);
			for(j = 0; j < this.gridSize; j++){
				usedGrid[i][j] = 0;
			}
		}
		do{
			i = rand(0, this.gridSize - 1);
			j = rand(0, this.gridSize - 1);
		}
		while( !this.pathGrid[i][j] );
		var positions = new Array(this.level + 2);
		positions[0] = new Coord(i,j);
		usedGrid[i][j] = 1;
		for(k = 1; k < this.level + 2; k++){
			do{
				i = rand(0, this.gridSize - 1);
				j = rand(0, this.gridSize - 1);
			}
			while (usedGrid[i][j] || this.grid[i][j]);
			positions[k] = new Coord(i,j);
			usedGrid[i][j] = 1;
		}
		shuffle(positions, this.level + 2);
		for(i = 0; i < this.level; i++){
			//console.log("sol[i]: " + this.sol[i]);
			this.grid[positions[i+2].x][positions[i+2].y]
				= new Bumper(this.sol[i], 0, 1);
		}
		var varSubset = new Array(this.level + 2);
		for(i = 0; i < this.level + 2; i++){
			varSubset[i] = this.variablePool[i];
		}
		shuffle(varSubset, this.level + 2);
		for(i = 0; i < this.level + 2; i++){
			this.clueGrid[positions[i].x][positions[i].y] = varSubset[i];
		}
		for(i = 0; i < 2*this.level; i++){
			this.clues[i] = this.substitute(this.cluePool[i],
				varSubset, 2 + this.level);
		}
		this.clues[2*this.level] = "There are " + this.level + " hidden mirrors";
		shuffle(this.clues, 2*this.level + 1);
	}

	this.substitute = function(clue, varArray, num){
		var str = clue.replace(/A1/g, varArray[0]).replace(/A2/g, varArray[1])
			.replace(/A3/g, varArray[2]);
		if (num > 3) str = str.replace(/A4/g, varArray[3]);
		if (num > 4) str = str.replace(/A5/g, varArray[4]);
		if (num > 5) str = str.replace(/A6/g, varArray[5]);
		return str;
	}

	this.getEndpoint = function() {
		return [this.side, this.index];
	}

	this.getBoard = function(shootSide = -1, shootIndex = -1){
		var board = new Array(this.gridSize);
		var i,j;
		for(i = 0; i < this.gridSize; i++){
			board[i] = new Array(this.gridSize);
			for(j = 0; j < this.gridSize; j++){
				board[i][j] = 0;
			}
		}
		if (shootSide == -1 && shootIndex == -1){
			for( i = 0; i < this.gridSize; i++){
				for ( j = 0; j < this.gridSize; j++){
					if (this.clueGrid[i][j]){
						board[i][j] = this.clueGrid[i][j];
					}
					else if (this.grid[i][j]){
						board[i][j] = this.grid[i][j].orient? 16:32;
					}
				}
			}
			return board;
		}
		else{
			var dir;
			switch(shootSide){
			case sideEnum.TOP:
				dir = dirEnum.DOWN.copyCoord();
				i = shootIndex;
				j = this.gridSize - 1;
				break;
			case sideEnum.BOTTOM:
				dir = dirEnum.UP.copyCoord();
				i = shootIndex;
				j = 0;
				break;
			case sideEnum.LEFT:
				dir = dirEnum.RIGHT.copyCoord();
				i = 0;
				j = shootIndex;
				break;
			case sideEnum.RIGHT:
				dir = dirEnum.LEFT.copyCoord();
				i = this.gridSize - 1;
				j = shootIndex;
				break;
			}
			do{
				if (this.grid[i][j]){
					board[i][j] |= (this.grid[i][j].orient? 16:32);
					if (dir.x == -1) board[i][j] |= 1;
					if (dir.x == 1) board[i][j] |= 2;
					if (dir.y == -1) board[i][j] |= 4;
					if (dir.y == 1) board[i][j] |= 8;
					dir = this.grid[i][j].reflect(dir);
					if (dir.x == -1) board[i][j] |= 1;
					if (dir.x == 1) board[i][j] |= 2;
					if (dir.y == -1) board[i][j] |= 4;
					if (dir.y == 1) board[i][j] |= 8;
				}
				else{
					if (dir.x != 0){
						board[i][j] |= (1 | 2);
					}
					else{
						board[i][j] |= (4 | 8);
					}
				}
				i = i + dir.x;
				j = j + dir.y;
			}
			while (i >= 0 && i < puzzle.gridSize && j >= 0 && j < puzzle.gridSize);
			return board;
		}
	}
}


/*
 * the bumper object has properties
 *	-orient, an orientEnum
 *	-decoy, is bumper a decoy bumper?
 *	-hidden, is bumper hidden by a variable?
 */

function Bumper(orientation, isdecoy=0, ishidden=0){
	this.orient = orientation;
	this.decoy = isdecoy;
	this.hidden = ishidden;

	this.reflect = function(direction){
		return reflectOrient(this.orient, direction);
	}

	//helper for reflect
	function reflectOrient(orientation, direction){
		var ref_dir = new Coord(direction.y, direction.x);
		if (orientation == orientEnum.REV){
			ref_dir.x = -ref_dir.x;
			ref_dir.y = -ref_dir.y;
		}
		return ref_dir;
	}
}

/*
 * coordinate object constructor
 *	-x
 *	-y
 */
function Coord(x_init, y_init){
	this.x = x_init;
	this.y = y_init;

	this.copyCoord = function(){
		return new Coord(this.x, this.y);
	}
}

/*
 * returns random integer in interval [min, max]
 */
function rand(min, max){
	return min+Math.floor((max-min+1)*Math.random());
}

function shuffle(array, length){
	var tmp;
	var i, randInd;
	for(i = length-1; i > 0; i--){
		randInd = Math.floor(Math.random()*(i+1));
		tmp = array[i];
		array[i] = array[randInd];
		array[randInd] = tmp;
	}
}

// //globals used for drawing
// var canvas = document.getElementById("canvas");
// var ctx = canvas.getContext("2d");
// var clueSpace = document.getElementById("hints");
//
//
// /********************************************DRAWING************************************************/
// function drawExit(puzzle){
// 	var cl = cellLength(puzzle);
// 	ctx.fillStyle = "rgb(50,255,50)";
// 	switch (puzzle.side){
// 		case sideEnum.BOTTOM:
// 			ctx.fillRect((1+puzzle.index)*cl, 0, cl, cl);
// 			break;
// 		case sideEnum.RIGHT:
// 			ctx.fillRect((1+puzzle.gridSize)*cl, (1+puzzle.index)*cl, cl, cl);
// 			break;
// 		case sideEnum.TOP:
// 			ctx.fillRect((1+puzzle.index)*cl, (1+puzzle.gridSize)*cl, cl, cl);
// 			break;
// 		case sideEnum.LEFT:
// 			ctx.fillRect(0, (1+puzzle.index)*cl, cl, cl);
// 			break;
// 		default:
// 			//console.log("Unexpected exit side");
// 	}
// }
//
// function drawGrid(puzzle){
// 	var cl = cellLength(puzzle);
// 	ctx.fillStyle = "rgb(255,255,255)";
// 	ctx.fillRect(0,0,canvas.width,canvas.height);
// 	ctx.strokeStyle = "rgb(50,50,50)";
// 	var i,j;
// 	for(i = 1; i <= puzzle.gridSize; i++){
// 		for(j = 1; j <= puzzle.gridSize; j++){
// 			ctx.strokeRect(i*cl, j*cl,
// 				cl, cl);
// 		}
// 	}
// }
//
// function drawBumpers(puzzle){
// 	var i, j;
// 	var cl = cellLength(puzzle);
// //	ctx.strokeStyle = "rgb(255,50,50)";
// 	for(i = 1; i <= puzzle.gridSize; i++){
// 		for(j = 1; j <= puzzle.gridSize; j++){
// 			if (!puzzle.grid[i-1][j-1]) continue;
// 			if (puzzle.grid[i-1][j-1].decoy){
// 				ctx.strokeStyle = "rgb(0,255,0)";
// 				//console.log("decoy\n");
// 			}
// 			else if (puzzle.grid[i-1][j-1].hidden){
// 				ctx.strokeStyle = "rgb(0,0,255)";
// 				//console.log("not decoy\n");
// 			}
// 			else{
// 				ctx.strokeStyle = "rgb(255,0,0)";
// 			}
// 			ctx.beginPath();
// 			switch(puzzle.grid[i-1][j-1].orient){
// 				case orientEnum.REV:
// 					ctx.moveTo( (i+1)*cl, (j)*cl);
// 					ctx.lineTo( (i)*cl, (j+1)*cl);
// 					ctx.stroke();
// 					break;
// 				case orientEnum.CONS:
// 					ctx.moveTo( (i+1)*cl, (j+1)*cl );
// 					ctx.lineTo( (i)*cl, (j)*cl);
// 					ctx.stroke();
// 					break;
// 				default:
// 					//console.log("Unexpected bump state during drawBumpers: "
// 						 //+ puzzle.grid[i-1][j-1].orient);
// 			}
// 			ctx.closePath();
// 		}
// 	}
// }
//
// function drawPath(puzzle){
// 	var i, j;
// 	var dir;
// 	var cl = cellLength(puzzle);
// 	switch(puzzle.side){
// 		case sideEnum.TOP:
// 			dir = dirEnum.DOWN.copyCoord();
// 			i = puzzle.index;
// 			j = puzzle.gridSize - 1;
// 			break;
// 		case sideEnum.BOTTOM:
// 			dir = dirEnum.UP.copyCoord();
// 			i = puzzle.index;
// 			j = 0;
// 			break;
// 		case sideEnum.LEFT:
// 			dir = dirEnum.RIGHT.copyCoord();
// 			i = 0;
// 			j = puzzle.index;
// 			break;
// 		case sideEnum.RIGHT:
// 			dir = dirEnum.LEFT.copyCoord();
// 			i = puzzle.gridSize - 1;
// 			j = puzzle.index;
// 			break;
// 	}
// 	ctx.fillStyle = "rgb(255,50,50)";
// 	do{
// 		//draw
// 		ctx.fillRect( (1+i)*cl, (1+j)*cl, cl/2, cl/2 );
// 		//reflect
// 		if (puzzle.grid[i][j]){
// 			dir = puzzle.grid[i][j].reflect(dir);
// 		}
// 		//update
// 		i = i + dir.x;
// 		j = j + dir.y;
// 	}
// 	while (i >= 0 && i < puzzle.gridSize && j >= 0 && j < puzzle.gridSize);
// }
//
// function drawRect(puzzle, canvas, e){
// 	ctx.fillStyle = "rgb(0, 50, 0)";
// 	ctx.fillRect(e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop, 10, 10);
// 	//console.log("length: " + cellLength(puzzle) + "\n");
// };
//
// /*
//  * finds the length of the side of a grid cell
//  */
// function cellLength(puzzle){
// 	var l = Math.min(
// 		Math.floor(canvas.width/(puzzle.gridSize+2)),
// 		Math.floor(canvas.height/(puzzle.gridSize+2))
// 	);
// 	return l;
// }
//
// function displayClues(puzzle){
// 	var str = "";
// 	var i;
// 	for(i = 0; i < 2*puzzle.level + 1; i++){
// 		str += puzzle.clues[i];
// 		str += "<br>";
// 	}
// 	clueSpace.innerHTML = str;
// }
//
// function drawGridClues(puzzle){
// 	var i,j;
// 	var cl = cellLength(puzzle);
// 	ctx.fillStyle = "rgb(0, 0, 255)";
// 	for(i = 0; i < puzzle.gridSize; i++){
// 		for(j = 0; j < puzzle.gridSize; j++){
// 			if (puzzle.clueGrid[i][j]){
// 				ctx.fillText(puzzle.clueGrid[i][j], (i+1)*cl + cl/2, (j+1)*cl + cl/2);
// 			}
// 		}
// 	}
// }

// /********************************RUN************************************************/
//
// var puzz = new puzzle(8, 4, 5, 5);
// puzz.createPathBumpers();
// puzz.decoyBumpers();
// puzz.createHiddenAndClues();
//
// drawGrid(puzz);
// drawExit(puzz);
// drawBumpers(puzz);
// //drawPath(puzz);
// displayClues(puzz);
// drawGridClues(puzz);
// canvas.addEventListener("mousemove", function (e){drawGrid(puzz); drawExit(puzz); drawBumpers(puzz); drawPath(puzz); drawGridClues(puzz); drawRect(puzz, canvas, e)});
